### Developer Frequently Asked Questions

#### What's the difference between `Enrollment.id` and `Enrollment.enrollment_id`?

* `Enrollment.id` is that database ID for the enrollment. It is unique in the Enrollment table. It is an incrementing numeric id that is generated by the database.
* `Enrollment.enrollment_id` is the `EnrollmentID` column on the Enrollment table. We use aliasing the snake-case the HMIS fields, so you can either use EnrollmentID or enrollment_id (snake-case is preferred). This ID is a String (32 char max) that is defined by the HMIS system that generated the data. For the OP HMIS, we use uuids. Other HMIS's use other conventions. This value is NOT unique in the Enrollment Table, but it _should_ be unique in combination with the `data_source_id`.
  * The above comments apply to ProjectID, PersonalID, OrganizationID, and HouseholdID.

#### What's the difference between `GrdaWarehouse::Hud::Enrollment` and `Hmis::Hud::Enrollment` models?

Both models are backed by the same table. We have separate model classes for the Warehouse and HMIS to encapsulate different logic. Shared logic is present in concerns (`app/models/concerns/hud_concerns`).

To translate between them, you can use the `as_warehouse` and `as_hmis` helper methods.

#### What's the difference between the `User` and `users` tables? Whats the `UserID` column all about?

| Database | Table name | Warehouse Model | HMIS Model | Usage |
| -------- | -------- | ------- | ------- |------- |
| `app` | `users` | `User`     | `Hmis::User` | This is the rails application user. Each record represents a user that can log into the application. These users have access controls, audit histories, and so on. If a user has access to multiple OP HMIS installations within one single warehouse, there will still just be one row in the `users` table for that user, and they'll use the same credentials to log in on each installation.
| `warehouse` | `User`  | `GrdaWarehouse::Hud::User`    | `Hmis::Hud::User` | These records are imported from external HMIS data sources, or generated from the OP HMIS. Imported records oftentimes do NOT correspond to any "real" application user. Table structure comes from `User.csv` specification. The `UserID` column from this table is present on all the other CSV-structured tables. In HUD's words, "UserID in this file is used to associate data in other CSV files with a specific user." When an HMIS application user touches a record, we generate a corresponding User record if it doesn't exist already

#### What's the deal with the `Custom<Something>` tables?

There are some tables used by OP HMIS that _look_ like CSV-structured tables, but they're not defined by the HUD spec. For example: `CustomAssessments`, `CustomClientAddress`, `CustomClientName`, etc.
The CSV specs have a "Custom file transfer template" indicating that HMIS systems can export custom data in files `Custom*.csv` as long as they follow the basic HUD-style format (using EnrollmentID, DateUpdated, DateCreated, etc.). Because of that, we decided to implement some of the custom HMIS data tables using this pseudo-HMIS-CSV structure.

#### How are permissions checked on GraphQL queries and mutations?

- Most HMIS records have a scope called `viewable_by`. Always use this scope when looking up a record. Most HMIS records' `viewable_by` scopes also perform a filter on `current_user.hmis_data_source_id`, ensuring that objects from other HMIS data sources are not included.
- When checking permissions, 90% of the time we want to check against a specific entity. (E.g. "can the user edit THIS enrollment?", not just "can the user edit any enrollments?"). The preferred way to do this is using `current_permission?(permission:, entity:)` because it uses the Graphql data loader and also ensures that the entity belongs to the correct data source.
- For nodes that are resolved from lots of places in the graph (and have PII), add object-level authorization to the object type (`def self.authorized?`). These are a secondary check to ensure the presence of the minimal permissions needed to resolve the object.

# How to Create a New Report

Follow these steps to create a new custom report.

1. Generate scaffolding for a new [Rails Driver](https://github.com/degica/rails_drivers):
    ```bash
    rails g driver custom_new_report_name
    ```
2. Add the relevant routes, controller, and view to the new Driver. See other examples for how they should be namespaced.
3. Add your new report to the `report_list` in the `GrdaWarehouse::WarehouseReports::ReportDefinition` model. Make sure to wrap it in a check to see whether the driver is loaded. See [ReportDefinition](https://github.com/greenriver/hmis-warehouse/blob/production/app/models/grda_warehouse/warehouse_reports/report_definition.rb) for examples.
4. Finally, run `rails db:seed` to populate the database with your new report definition. Alternatively, you can run the two relevant steps individually:
    ```ruby
    # Generates a new ReportDefinition
    GrdaWarehouse::WarehouseReports::ReportDefinition.maintain_report_definitions
    # Adds the report to the "all reports" group
    AccessGroup.maintain_system_groups
    ```
